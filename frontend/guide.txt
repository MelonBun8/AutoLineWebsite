PASSWORDS::
- Nomaan - pass

Before beginning to create the frontend, you need to decide the 
- state management
- file structure
- routing structure

Redux is a JS library for global state management. Redux logic is controlled through the redux toolkit. It solves the problem of prop-drilling, where multiple components (typically parents and their children) use the same prop (argument passed into react components)


Table tutorial with grid:
Ah! Now I understand what your tutorial meant by "flattening a table before passing it to grid." This is actually a modern CSS Grid technique for styling tables while maintaining semantic HTML. Let me break it down:

The "Flattened Table" Approach
This method uses CSS Grid to style traditional HTML tables by:

"Flattening" the table structure with display: contents

Makes <thead>, <tbody>, and <tr> invisible to grid layout

Only <th> and <td> become direct grid children

Treating cells as grid items

Columns are controlled by grid-template-columns

Rows are implicit (auto-generated by content)

Why Your Fix Worked
css
Copy
/* Before (Broken) */
.table__deal-reports {
  grid-template-columns: repeat(2, 1fr) 3fr repeat(2, 1fr); 
  /* Total: 5 columns */
}

/* After (Fixed) */
.table__deal-reports {
  grid-template-columns: repeat(3, 1fr) 3fr repeat(2, 1fr);
  /* Total: 6 columns */
}
Mismatch Issue: Your table has 6 columns (Serial, Created, Updated, Creator, Edit + possibly an extra one), but the original CSS defined only 5 grid columns.

Solution: Adding the missing column (repeat(3, 1fr) instead of repeat(2, 1fr)) aligned the grid with your actual table structure.

Key CSS Rules Explained
Rule	Purpose
thead, tbody, tr { display: contents; }	"Flattens" table structure; makes rows/headers invisible to grid
.table { display: grid; }	Turns the table into a grid container
grid-template-columns	Defines column widths (must match actual column count)
gap: 0.1em	Adds spacing between cells (normally impossible with HTML tables)
Why This Approach?
Benefits:

Enables gap spacing between cells (impossible with traditional tables)

Allows responsive layouts with media queries

Mixes semantic HTML with modern layout

Tradeoffs:

Requires exact column count matching

Can break screen readers if overused (though your semantic HTML helps)

Final Recommendations
Audit Your Columns:
Count all visible/hidden columns in both <thead> and <tbody>.

Redux has mutations, queries, actions and reducers

html
Copy
<!-- Example: 6 columns -->
<th>Serial</th>    <!-- 1 -->
<th>Created</th>   <!-- 2 -->
<th>Updated</th>   <!-- 3 -->
<th>Creator</th>   <!-- 4 -->
<th>Edit</th>      <!-- 5 -->
<!-- +1 implicit column? -->
Run HTML
Debugging Tip:
Add temporary borders to see all cells:

css
Copy
.table__th, .table__cell { border: 1px solid red; }
Alternative:
If this feels too hacky, consider switching to a pure CSS Grid layout (without <table> tags) or a traditional table layout.

This technique is powerful but requires precision. Your fix worked because you reconciled the column mismatch! ðŸŽ‰

---REACT HOOKS---
Before React Hooks, if you wanted to trigger re-renders on data-change within a component, you had to use class components and attributes like this.state and 
lifecycle methods like componentDidMount etc. This became tedious to manage hence React Hooks fixed this with a simpler useState,
and useEffect hooks (Functional components).
useState allows state declaration directly within functional components (WITHOUT NEEDING TO CONVERT IT TO A CLASS!!!)
useEffect allows functional components to perform side effects like data-fetching, subscriptions, or manual DOM change previous handled
by lifecycle methods in the class.
Everytime a setter for useState is called, it triggers a re-render (Basically when a component changes, it's re-rendered) 

Redux terms: 
Store: This is a single source of truth for the application's state in a Redux-like setup. It holds the entire state tree. The store provides methods to:

getState(): Retrieve the current state.
dispatch(action): Send an action to the reducers to update the state.
subscribe(listener): Register listener functions that will be called whenever the state changes.

State: This is the heart of a React component. It's a plain JavaScript object that holds data that can change over time and affects the component's rendering behavior. When state changes, the component re-renders.

Actions: These are plain JavaScript objects that describe an event that has occurred or an intention to change the state. They are the only way to trigger a state change in a Redux-like pattern. Actions typically have a type property (a string constant) that identifies the action and may include other data (the payload) needed to update the state.

Reducers: These are pure functions that take the current state and an action as arguments and return a new state. They specify how the application's state changes in response to 1  an action. Importantly, reducers should be immutable, meaning they should not modify the existing state directly but instead return a new state object. Â  

Slices: This term is often associated with Redux Toolkit. A slice is a logical grouping of Redux state, reducers, and action creators into a single file. It simplifies the process of defining and managing related state and logic. A slice typically defines an initial state and a set of reducer functions that operate on that slice of the overall state.

Subscriptions: This refers to the mechanism that allows components or other parts of the application to be notified whenever the state in the store changes. When a component subscribes to the store, a listener function is registered. This listener is then executed every time an action is dispatched and the state is updated, allowing the component to re-render or perform other side effects based on the new state.

Authentication vs Authorization:
- Authentication is verifying who someone is.
- Authorization is verifying what resources a user has access to.

After logging in, app users will be issued JSON web tokens (JWT)
JWT has an authorization header sent with every HTTP request. This allows access to only permitted API endpoints.
API endpoints then in turn provide data resources.